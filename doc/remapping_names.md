元の文書  
https://design.ros2.org/articles/static_remapping.html

# 名前のリマッピング

トピックやパラメータ，サービスは名前によって一意に定まります。名前はROSノード内でハードコードされますが，それらはリマッピング機能を通して実行時に変更できます。リマッピングがなければ，ノードのインスタンスはコード内で変更を要求します。この記事はROS2におけるリマッピングの仕様，根拠およびメカニズムについて説明します。

## なぜ名前を再配置(リマップ)するのか

名前の再配置は異なるシステムにおいて同じノードを再利用できるようにするためのものです。あるロボットが似たタイプのセンサを複数持っていると，そのロボットは異なるトピックへとリマップしたセンサ出力のある同じノードの複数インスタンスを起動します。


## 名前の構造
名前の完全な定義は[こちら](http://design.ros2.org/articles/topic_and_service_names.html)に記載しています。この記事を読む前にリンク先を読んでおくべきです。

### 簡単なまとめ
`/`から始まる名前は「完全修飾名(FQN)」，そうでない場合は「相対名」と呼ばれます。スラッシュ間の文字列はトークンと呼びます。名前は概念上2つの要素に分かれます。「名前空間」と「ベース名」です。ベース名は名前の最後のトークンです。名前空間はベース名の前にある文字列すべてです。

### 名前の例
- `/foo`
- `/foo/bar`
- `~/foo/bar`
- `{node}/bar`
- `bar`

## リマッピング操作の構造

リマッピング操作はノードが使用する名前をどのように変更すべきかを説明する指標です。リマッピング操作には2つの要素があります。1つ目はその操作が名前に対して適用できるかどうかを判断するために使われます。2つ目は一致する名前との入れ替えです。ある名前を別の名前と入れ替える行為が「リマッピング」です。

## ROS2におけるリマッピングのユースケース

次のユースケースはROS2におけるリマッピングのために考えられているものです。

- プロセス内の1つのノードをリマップする。
- 名前空間を変更する。
- ベース名を変更する。
- トークンを変更する。
- 事前のFQNをリマップする。
- 詳細にFQNを取り替える。
- 詳細に相対名を取り替える。
- コマンドラインを介してリマップする。
- デフォルトの名前空間を変更する。
- ノード名を変更する。
- トピックとサービス名を別々にリマップする。

### プロセス内の1つのノードをリマップする

これは1つのプロセスの1つのノードに対して，ほかのノードへの影響なく，リマップ操作を適用する機能のことです。ROS2におけるプロセスは複数のノードを含むことができるので，1つのプロセスにおける複数のノードが異なる目的で同じ名前を使用する可能性があります。ユーザーは停止することなく，1つのノードに使われている名前を変更したいかもしれません。

### 名前空間を変更する

ノードは名前空間にある，またはデフォルトの名前空間を持っていると言われています。この名前空間はノードによって使用されているすべての相対名を先頭に追加します。このユースケースは1つの操作で複数の名前空間を変更する機能があります。

人気のROS1パッケージ[actionlib](wiki.ros.org/actionlib)は同じ名前空間に5つのトピックを生成します。ROS1のactionlibのクライアントまたはサーバーをリマッピングするということは5つのリマッピング操作を生成することを意味します。ROS2ではすべてのリマップ操作を1回で済ませることができます。

例：
- ノードはactionlibサーバ`move_head`を提供し，`move_head`と呼ばれるパラメータをチェックします。
- リマップ操作は名前空間である`move_head`と`move_head_check_collision`を入れ替えます。
- 5つすべてのactionlibトピックは`/move_head_check_collision`にリマップされますが，パラメータ名は変更されないままです。

### ベース名を変更する

これは1つの操作で複数のベース名を変更できる機能です。ユーザーは1つのベース名をもつ複数のインスタンスを別のトークへと変更できるようになります。

例：
- あるノードは`/scan/head/scan`と`/base/scan`という名前を持っている。
- ユーザーはいくつかのノードを起動した後，そのノードに同じデータをサブスクライブさせたい。
- ユーザーはベース名である`scan`を`scan_filtered`にリマップする。
- 最終的なトピックは`/scan/head/scan_filtered`と`/base/scan_filtered`となる。

### トークンを変更する

これはトークンがどこにあろうとも，複数の名前のトークンを変更する機能です。トークンはインターフェイスを通して使用される可能性がありますが，エンドユーザーにとっては望ましくありません。これはこのトークンのすべての使用を取り替える操作を可能にすることを意味します。

例：
- ある会社がROS2ドライバーを備えた汎用移動ロボットベースを売り出しています。
- ロボットベースのドライバーはその中に`UmbrellaCorp`のような会社名をたくさん使っています。
- ほかの会社はロボットベースを製品に組み込んでおり，その会社のお客様はROS2のインターフェイスを利用したいです。
- 2つ目の会社は彼らのインターフェイスに`UmbrellaCorp`を含ませたくまりません。そこで彼らはドライバーを起動するときにトークンを`moble_base`にリマップします。

### 事前のFQNをリマップする

これはコード内で使用されるように名前を一致させる機能です。このためにはFQNへ展開する前に一致させる必要があります。これは2つの異なる名前が同じFQNに展開されるときに便利です。

例：
- あるノードは2つの名前`cat`と`/ns/cat`を使用しています。
- ノードは名前空間`/ns/`内で動作しており，その2つのFQN名は`/ns/cat`です。
- リマップ操作によって`cat`から`lion`へ事前のFQNを展開します。
- 最終的な名前は`/ns/lion`と`/ns/cat`になります。

### 詳細にFQNを取り替える

これは正確に名前をマッチさせることで名前を入れ替える機能のことです。これはROS1のリマッピングの振る舞いの一部であり，便利さは証明され，ROS2へ転用することは容易です。

例：
- あるノードが`/ns/bar`と`/ns/barista`を使っている。
- ある操作は`/ns/bar`から`/ns/foo`へのリマップです。
- 最終的な名前は`/ns/foo`と`/ns/barista`です。

### 詳細に相対名を取り替える

これはユーザーが相対名を別の名前へとリマップできるようにします。初めに相対名を展開し，その後FQNを入れ替えるように働きます。これもまたROS1リマッピングの一部の機能です。

例：
- あるノードは`/ns/`名前空間の中で`bar`を使っています。
- 操作は`bar`を`foo`へリマップすることです。
- `bar`のノード仕様は`/ns/bar`へと展開します。
- リマップの両サイドは`/ns/bar`と`/ns/foo`へと展開します。
- FQNが一致するので，最終的な名前は`/ns/foo`になります。

### コマンドラインを介してリマップする

ユーザーはノードへコマンドラインを介して特定のリマッピング引数を指定できます。あるプロセスが複数のノードを含んでいるので，プロセス内でユニークにノードを特定する方法が必要です。これはROS1のリマッピングの機能です。

例：
- ノードは`/bin/my_node`で実行可能です。
- ユーザーは`/cat/`から`/dog`に変更したいです。
- ユーザーは`/bin/my_node /cat:=/dog`とタイプします。

### デフォルトの名前空間を変更する

デフォルトの名前空間は相対名が展開したものです。これはFQNの影響なしに変更可能であるべきです。ROS1は環境変数`ROS_NAMESPACE`を使うか，`__ns`という引数を使うことでこの機能を有しています。

例：
- ノードは`/ns`という名前空間で相対名`bar`を使っています。
- ユーザーはデフォルトの名前空間を`/foo`へと変更します。
- 最終的な名前は`/foo/bar`となります。

### ノード名を変更する

ノード名はログメッセージ内やプライベート名を生成するために使われます。ROS1は`__node`引数を使うことでこの機能を有しています。

例：
- ノードは`camera_driver`と名付けられ，プライベートな名前`camera_info`を使います。
- ユーザーはノード名を`left_camera_driver`に変更します。
- 最終的な名前は`/ns/left_camera_driver/camera_info`となり，ロギングメッセージは`left_camera_driver`を使います。

### トピックとサービス名を別々にリマップする
これはトピックだけとサービスだけをリマップするための処理を生成する機能です。

例：
- ノードは`/map`トピックをサブスクライブし，`/map`サービスに要求します。
- ユーザーはトピック名を`/map_stream`に変更します。
- 個のノードは`/map_stream`トピックをサブスクライブし，`/map`サービスに要求します。

## ROS1における名前のリマッピング
リマッピングはROS1にも存在する機能です。ROS1では，リマッピングはお互いのノードに対して[引数](http://wiki.ros.org/Remapping%20Arguments)を通過することで作用します。クライアントライブラリ(ROS2)でもノードが初期化されるときに，リマッピング操作を通過するようなAPIをコード内に持ちます。リマップ操作は2つの名前が存在します。つまり，1つの名前と，ほかの名前と取り替えられる名前の2つです。

ROS1のリマッピングは完全修飾名(FQN)にて作用します。リマップ操作の両サイドは[FQNに展開されます](http://docs.ros.org/kinetic/api/roscpp/html/namespaceros_1_1names.html#a377ff8fede7b95398fd5d1c5cd49246b)。名前はリマップされる前に，[FQNに展開されます。](http://docs.ros.org/kinetic/api/roscpp/html/namespaceros_1_1names.html#ab2eebaf734abfbdccb4122f8e24f547f)その名前は左側の名前と正確に一致した時だけ右側の名前とリマップされます。

### リマッピング操作の構文

これはROS2のリマッピング操作構文の提案です。可能な限り，ROS1と同じになるようにしています。

ユースケースは次の構文をサポートします。
- 1つのプロセス内で1つのノードのリマップ
- 名前空間の変更
- ベース名の変更
- 正確なFQNの入れ替え
- 正確な相対名の入れ替え
- コマンドラインからのリマップ
- デフォルト名前空間の変更
- ノード名の変更
- トピックとサービスの別々なリマップ

以下はサポートされていません。
- トークンの変更
- 事前のFQNのリマッピング

### どのように構文は作用するのか
リマッピング操作の構造は`match:=replacement`です。`match`は名前がリマップされるべきかどうかを検証します。`replacemant`は新しい名前が何になるかを明言します。`:=`はROS1と同じようにふるまいます。

例：
- `foo:=bar`
- `/foo/bar:=fiz/buzz`
- `nodename:~/foo:=foo`
- `**/foo:=\1/bar`

#### 操作の一致部分(左辺側)

操作の一致部分は以下の演算子を使います。

- `*`は1つのトークンと一致します。
- `**`はスラッシュで区切られた0個以上のトークンと一致します。
- `rosservice://`のような接頭辞はサービスのみに適用する操作です。
- `rostopic://`のような接頭辞はトピックのみに適用する操作です。
- `nodename:`のような接頭辞はそのノードにのみ適用する操作です。

`*`や`**`のような演算子はbash内のグロブの振る舞いに似ています。`**`はグロブスターオプションのある4.0以降のbashと似た振る舞いをします。

URLスキームである`rosservice://`や`rostopic://`はトピックやサービス名への操作にのみ与えられるかもしれません。これらはノード名や名前空間の変更操作(`__node`や`__ns`)では接頭辞として付けないかもしれません。もしノード名の接頭辞とURLスキームが与えられたら，そのノード名の接頭辞が初めにきます。；
`*`や`**`はトークン全体にのみ一致します。`*bar`は`foobar`と一致するように見えますが，これは一部のトークンと一致することを意味します。混同を避けるために，`*`や`**`はトークンや置換，`/`からお互いを分離する必要があります。例えば，`*/bar`,`**/*`,`~/*`は許されますが，`*bar`,`***`,`~*`は無効です。

一致検証はFQNにのみ作用します。ある名前が検証されるとき，名前やリマッピング操作野中の代入演算子(`~`や`{}`)は中身を表す文字列と置き換えられます。そして名前はFQNへと展開されます。操作の一致部分が`/`,`*`または`**`で始まらなかった場合，それをFQNとするために`/namespace`を接頭辞に付け加えます。最終的に，その名前は操作の一致部分に対して比較されます。その名前が一致したらそれはリマップされます。

#### 操作の入れ替え部分(右辺側)

これらの特別な演算子は操作の入れ替え部分においてユニークです。

- `\1`-`\9`は`*`または`**`の一致した文字列と入れ替えられます。

`\1`から`\9`の構文はPOSIX基本正規表現におけるバックリファレンスを引き継いでいます。しかしながら丸括弧は使われていない(ワイルドカードが常にキャプチャしてしまうため。)。

これらの参照は`/`によってトークンから分離される必要があります。これは`//`を含む名前を生成するとき，1つのスラッシュは自動的に削除されることを指します。例えば`**/bar:=/bar/\1`は`**`が`/foo`をキャプチャすることで`/foo/bar`とマッチしますが，新しい名前は`/bar/foo`です。

操作の入れ替え部分はURLスキームを持たないかもしれません。これはマッチ側のスキームタイプと入れ替え側のスキームタイプの間でミスマッチすることを避けるためです。

代入演算子(`~`や`{}`)は初めに入れ替えられます。そのあと，参照演算子は一致した文字列と入れ替えられます。そして入れ替えた名前が`/`で始まらなかったら，FQNにするためにノードのデフォルト名前空間が自動的に接頭辞につきます。最終的には，名前は入れ替えられます。例えば，`/bar/*:=\1/bar`は`*`が`foo`をキャプチャすることでデフォルト名前空間が`/ns`であるノード`/bar/foo`とマッチし，`/ns/foo/bar`という名前に入れ替わります。

#### デフォルト名前空間を変更する特別な操作

文字列`__ns`はデフォルト名前空間の変更を示すために操作の一致部分に与えられます。一致する側では`__ns`は単独で使われるか`nodename:`という接頭辞付きで使われなければなりません。操作での入れ替わる側は新しいデフォルト名前空間となるFQNを持っていなければなりません。

#### ノード名を変更する特別な操作

文字列`__node`はノード名の変更を示すために示すために操作の一致部分に与えられます。一致する側では`__name`は単独で使われるか`nodename:`という接頭辞付きで使われるかかもしれません。入れ替えはノードの新しい名前になる1つのトークでなければなりません。

#### リマップ操作を適用する順番

リマップ操作は以下の順番で適用されます。

- ノード名のリマッピング
- 名前空間のリマッピング
- すべてのその他の操作

各カテゴリ内で，操作はユーザーが与えた順序でルールが適用されます。

**トピック/サービスのリマッピング順序の例:**

- あるノードは`/foo/bar`という名前を用いています。
- あるユーザーはノードに`/*/*:=/asdf`という操作のあと`/foo/bar:=fizzbuzz`という操作をします。
- 最終的な名前は`/asdf`となります。なぜなら，1番目の操作でリマップされてしまうので，2番目の操作と一致しなかったからです。

**ノード/名前空間のリマッピング順序の例:**

- `talker`という名前のノードがあります。
- あるユーザーは`talker:__ns:=/my_namespace`をし，`talker:__node:=foo`という操作をします。
- 最終的な名前空間は`/`です。なぜなら，ノード名のリマップは名前空間のリマップの前に適用されるからです。

**デフォルトやノードの特定の名前空間のリマップの例:**

- `talker`という名前のノードがあります。
- あるユーザーは`talker:__ns:=/foo`という操作をし，`__ns:=/bar`という操作をします。
- talkerの名前空間は`/foo`です。なぜならその操作が初めに与えられたからです。

### 構文のアプリケーション

次のセクションではどのようにして構文が上記のユースケースを可能にするのかについて説明します。

#### 1つのプロセスで1つのノードをリマップする(サポート済み)

1つのプロセスで1つのノードをリマップすることはノードをユニークに特定する方法が必要です。ノード名が1つのプロセス内でただ1つであると仮定すると，操作は目的のノードと`:`が先頭にあるノードに適用されます。ノード名が先頭にない場合，操作はプロセス内のすべてのノードへ適用されます。

例：
- 1つのプロセス内の複数のノードが`scan`を使っている。
- `node1:scan:=scan_filtered`は1つのノードに対して与えられる。
- `node1`と名づけられた名前だけその操作を利用する。；

#### 名前空間の変更(サポート済み)

これには名前空間の一部を変更する場合と名前空間の全体を変更する場合の2つのケースがある。1つ目のケースは名前空間の残りと一致するためのワイルドカードが必要となります。2つ目のケースは最後のベース名と一致するワイルドカードが必要となります。

名前空間の一部を変更する例：
- ノードは`/foo`,`/foo/bar`,`/foo/bar/baz`を使っている。
- ノードは`/foo/**:=/fizz/\1`の操作を与えられる。
- その結果，`/foo`,`/foo/bar`,`/fizz/bar/baz`となる。

名前空間の全体を変更する例：
- ノードは`/foo/bar/baz`,`/foo/bar/fee/biz`を使っている。
- ノードは`/foo/bar/*:=/bar/foo/\1`という操作を与えらえる。
- その結果，`/bar/foo/baz`,`/foo/bar/fee/biz`となる。

#### ベース名の変更(サポート済み)

ベース名の変更は全体の名前空間と一致するワイルドカードが必要です。ワイルドカード`**`はスラッシュで囲まれたすべての名前空間と一致するので便利です。

例：
- ノードは`/foo`,`/buz/foo`,`/biz/buz/foo`を使っている。
- ノードは`**/foo:=\1/bar`という操作を与えられる。
- その結果，`/bar`,`/buz/bar`,`/biz/buz/bar`になる。

#### 正確なFQNの入れ替え(サポート済み)

正確なFQNの入れ替えにはワイルドカードは必要ありません。この構文はROS1と同じです。

例：
- `/foo/bar:=/fiz/buz`
- `/foo:=/foo/bar`

#### 正確な相対名の入れ替え(サポート済み)

正確な相対名の入れ替えもまたワイルドカードは必要ありません。つまり，相対名は初めにFQNに展開されることを意味し，正確なFQNの入れ替え中に処理されることを意味します。構文はROS1と同じです。

例：
- 名前空間`/ns`内での`foo:=/foo/bar`は`/ns/foo:=/foo/bar`と同じです。
- 名前空間`/ns`内での`foo:=bar`は`/ns/foo:=/ns/bar`と同じです。
- 名前空間`/ns`内での`/foo/bar:=foo`は`/foo/bar:=/ns/foo`と同じです。

#### コマンドラインを介したリマップ(サポート済み)

ここでの構文はコマンドラインを介してノードを通過します。構文はbash内で特別なシェル文字と競合せずに選ばれます。例えば，bashでは`*`という文字は空白で囲まれている場合に特別なふるまいをしますが，リマップ操作は空白を含みません。この文字はzshのようなほかのシェルにはまだ難しいかもしれません。

#### デフォルト名前空間の変更(サポート済み)

これは本当はリマップ操作ではないですが，構文は同じです。ROS1では，`__ns:=`という引数はデフォルト名前空間を変更できました。ここでは，構文は同じで，さらにノードの名前に接頭辞を付けられます。入れ替え側は特別な演算子なしにFQNを持たなければなりません。すべてのリマップ操作が適用される前に，相対名は新しい名前空間に展開されます。

例：
- `__node:=left_camera_driver`
- `camera_driver:__node:=left_camera_driver`

#### トピックとサービスの別々なリマップ(サポート済み)

リマップ操作のマッチ側にURLスキームを指定すると，1つの名前のタイプにのみ排他的に処理にします。もしURLスキームが与えられなかったら，リマップ操作はトピックとサービスの両方に適用されます。

例：
- `rosservice:///foo/bar:=/bar/foo`
- `rostopic:///foo/bar:=bar/foo`
- `nodename:rosservice://~/left:=~/right`

#### トークンの変更(未サポート)

構文は1つの操作でトークンのすべてを変更できません。このユースケースを1つの操作でサポートすることは優先していません。

2つの操作を使った回避策：
- 初めの操作は名前空間にて使用されるトークンをリマップする。`**/foobar/**:=\1/fizzbuz/\2`
- 2つ目の操作はベース名として使用されるトークンをリマップする。`**/foobar:=\1/ffizzbuz`

#### 事前のFQNのリマッピング(未サポート)

構文には，FQNの前にリマップ操作を適用することを指定する方法がありません。回避策はありません。

### fnmatch(ファイル名パターンマッチ)構文

fnmatchのような構文は想定されています。ワイルドカードのための文字`*`がfnmatchに一致するように選ばれました。リマッピングは入れ替えの間に使用する文字をキャプチャする必要があるので，Cの関数`fnmatch()`は実装には使用できません。`?`や`[]`のような追加のワイルドカードは上記のより多くのユースケースを実現可能にするようには見えません。fnmatch構文は`FNM_PATHNAME`オプションに依存するスラッシュ付きのテキストにマッチするかもしれないし，しないかもしれません。

# 静的VS動的リマッピング

静的リマッピングではノードが起動した時にノードへリマップ操作を与えることです。動的リマッピングとは，ノードが動作中に名前をリマップする機能のことです。これはノード開発を始めたばかりで，異なるソースへ名前を修正したいような開発者にとって便利かもしれません。ユーザーは静的な操作でリマップされた名前を見るので，動的祖操作は静的な操作の後に適用されます。この新しいリマップ操作の方法は，コードに記述されたオリジナルの名前よりもむしろイントロスペクションツールでユーザーに表示される名前に対して一致します。