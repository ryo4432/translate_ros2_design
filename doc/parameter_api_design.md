元の文書  
https://design.ros2.org/articles/ros_parameters.html

# ROSにおけるパラメータAPIの設計

この記事は，ROS2のパラメータとやり取りするためのインターフェイスの設計案です。私たちはここではシステム設計を明記することに焦点を当て，実装については明記しないままにします。

# 背景
ROS1では，パラメータは「ブラックボードパターン」で実現されており，すべてのノードから制限のなく読み書きのアクセスが可能でした。このデータモデルは多くのケースで有用であることを証明しましたが，コントロールや所有権の欠如において問題があることを示す多くのケースがありました。よく言われている欠点の1つに，ドライバーのパラメータ設定があります。dynamic_reconfigureと呼ばれるツールはこのユースケースを対処するために開発されました。dynamic_reconfigureは，ほかのノードのパラメータとやり取りするために，サービスベースのインターフェイスを提供しました。

## そのほかの資料
ROS2のパラメータ設計過程に関して，次の資料を含んでいます。
- Gonzalo’s research on parameters.
    - Discussion: https://groups.google.com/forum/#!topic/ros-sig-ng-ros/YzCmoIsN0o8 and https://groups.google.com/forum/#!searchin/ros-sig-ng-ros/parameter/ros-sig-ng-ros/fwDBcei5Ths/L6ORPfjUDXYJ
    - Prototype: https://github.com/abellagonzalo/dynamic_config
    - Final Notes: http://wiki.ros.org/sig/NextGenerationROS/Parameters
- Thibault’s nodeparam draft REP: https://github.com/tkruse/rep/blob/nodeparam/nodeparam-REP.rst


# 理想的なシステム
新しく作るパラメータシステムが現在のシステムにどのように働き，どのように作用するのかを理解するためには，理想的なステムを考えると便利です。理想的なシステムは，ROS1に組み込まれているパラメータ機能のユースケースだけでなく，ROS1の動的なパラメータシステムを兼ね備えたシステムをサポートします。理想的なシステムは以下の基準を満足するようにします。
- パラメータの設定機能  
    アトミックに(不可分に)パラメータ群を設定します。
- パラメータの取得機能  
    アトミックにパラメータ群を取得します。
- パラメータの取り消し機能  
   これはアトミックにパラメータ群を取り消しますが，アトミックにパラメータ群を設定する特別なケースかもしれません。
- 設定済みパラメータの表示機能  
    パラメータの数は膨大になることがあるので，パラメータをある程度の塊として提供できる必要があります。(例：パラメータはツリー構造のGUIで順番に問い合わせできる。)
- パラメータが追加・削除・変更されたときの通知機能  
- パラメータ変更操作を棄却する機能  
    これは，いくつかの存在(ここではパラメータ操作をしたいユーザーやノードのこと？)が任意の基準(パラメータのデータ構造・操作方法)に基づいて変更操作を棄却または承認する権利を有することを意味しています。これは，変更の受け入れのための基準の少なくとも一部を外部のアクターへ伝える能力があることも意味します。例えば，整数や2,3個の文字の範囲で通信しているとします。このような情報は包括的なユーザーインターフェイスを作り出せるようになりますが，すべての基準を網羅できないかもしれません。検証基準は任意の複雑さがあり，潜在的にクライアントと通信できないので，もしその値が(現在の基準に基づいて)承認されるのであれば，パラメータサーバはアトミックなパラメータ群を検証し，ブール型のフラグを返すような提案ができます。値が設定された直後では，結果が異なるかもしれませんが，一般的にはGUIのようなもので検証者がその実行を許可する。
- どんなパラメータが検証を通過し，棄却されたかの可視性を提供する機能  
    値を更新したときに，実際には変更を要求することなしにパラメータ更新を受け入れるかどうかを知ることは価値があります。
- パラメータの生存期間に関する明確なルールの提供  
    パラメータの生存期間が何で，どのような条件でもって値をクリアするかをこれらのルールが定義します。
- 名称の曖昧さなしにすべてのパラメータを取り扱う機能  
    たとえば，現在のシステムの課題に一つに，ノード名とパラメータ名の間で名前付けの曖昧さが存在することがあって，`/foo/bar/baz`という名前は`/foo/bar/baz`という名前のノードになれることや，ノード`/foo/bar`のプライベートパラメータ`baz`になれることがあります。
- 後で再生や解析ができるようなロギング機能

## 提案手法
上記の機能を網羅するために，ROS2のパラメータシステムでは次の手法を提案しています。

### ノードにホストされたパラメータ
パラメータのライフサイクルを検証するために，すべてのパラメータはノードによってホストされます。それらの生存期間は厳密にノードの生存期間と結び付けられます。ノードは現在の値を検証する責任があります。ノードは再起動した後に過去のパラメータを再度読み込むためにパラメータの永続性を実現することもできます。

### パラメータへの参照
すべてのパラメータは「ノード名のフルパス」と「パラメータ名のフルパス」の2つの要素によって参照されます。

### データ型のサポート
各パラメータはキーと値を持ちます。キーは文字列であり，値は以下のデータ型のうちの1つです。
- `bool`
- `int64`
- `float64`
- `string`
- `byte[]`
- `bool[]`
- `int64[]`
- `float64[]`
- `string[]`

データ型は[インターフェイス定義の記事](https://design.ros2.org/articles/interface_definition.html)にて定義されているように，データ型同士が混在することなく選ばれます。異なるビット深度や符号付けのあるデータ型のすべての構成はテキストベースの構成ファイルを解釈することで避けられます。  
データ型の配列は以下のようなユースケースをサポートしています。
- `byte[]`はバイナリーデータを保存できるようになっています。`byte[]`の使用は推奨されていませんが，とても便利に利用できることもあり，文字列のようなほかのデータ型を乱用したい人々がいるよりはましなので，明確にサポートしています。
- `bool[]`はほかのパラメータ配列をマスク処理するのに便利です。
- `int64[]`や`float64[]`は数値のベクトルおよび行列となるパラメータを表現するのに使えます。
- `string[]`は名前のグループを表現するために利用できます(たとえば，複数のロボットが存在して，それを名前付けしたい時など)。

パラメータ配列の使用はAPIの複雑さを増長させる一方で，それらを省略することは，複数の行列で構成したパラメータのように，複雑な名前付け構成となってしまうことは避けて通ることができませんが，ロボットの世界ではこういうことは一般的なことです。

ただ1つの同種のデータ型配列がサポートされます。これは配列内の多次元性や不均一性を処理するために必要になるイントロスペクションが不必要に複雑になることを避けるためです。

ただし，配列を多用すべきではないです。ユーザーは可能な限り名前空間や明確な変数名に依存すべきです。

### 必要な機能

各ノードは以下に示す機能を提供する能力があります。
- パラメータの取得  
    パラメータ名のリストを与えられたら，そのパラメータの値を返します。
- パラメータの設定  
    パラメータ名のリストを与えられたら，検証済みの値の更新を要求します。更新される値には，値の取り消しも含みます。値のどれかが検証に失敗した場合にどの値も設定されないように，値のセットをアトミックに更新できるAPIを提供します。この成功・失敗は各更新単位でクライアントが利用できるようになります。値の検証はできる限り早く返答し，設定要求の承認または棄却にのみ関係することを期待されます。変更された値がノードやそれ以上の大きいシステムの現行の性能に対して度のよな影響を与えるのか与えないのかに関しては考慮すべきではないです。
- パラメータの一覧表示  
    現在設定されているパラメータ名のリストを提供します。
- パラメータの詳細表示  
    パラメータ名のリストが与えられたら，それらのデータ型を返します。

この機能性は，ユーザーAPIを通して公開されます。そしてユーザーAPIはローカルAPI呼び出しだけでなく，ROSサービスAPIを介した遠隔ノードからの呼び出しの両方をサポートします。

### パラメータ更新の検証

ノードは依頼されたパラメータ変更を検証でき，それらを承認・棄却することができます。

### パラメータサーバのような動作での後方互換性

パラメータサーバのように，古い振る舞いが便利だったというユースケースがあります。特定のノードの持続時間を超えてパラメータが存続することは，値を所有し検証する可能性のあるノードと特定の関係付けのないパラメータを持つことと同じように価値があります。この目的のために，私たちはROS1のパラメータサーバーのポリシーを見習ったシンプルなノードを書くことを提案することにしました。すなわち，`/`で名前空間を区切り，すべての変更要求を単に受け入れるということです。パラメータサーバノードによって保持されたパラメータはパラメータサーバノードの生存期間存在し続けます。異なったパラメータ存在モデルをサポートするために，異なる名前空間に特定のインスタンスを立ち上げることができます。

### パラメータの振る舞いの検索

ROS1で開発されたパターンは`searchParam`モデルであり，パラメータは名前空間ごとに設定され，パラメータへの問い合わせはパラメータを検索するための名前空間を呼び起こすというものでした。階層的な順序で異なるノード間を行き来するためのパラメータ検索の実装を許可することで，これと似た振る舞いを実現できるようになりました。

### パラメータAPI
クライアントライブラリでは，リターンコードを含むローカルおよび遠隔ノードの両方のためのコアパラメータAPIとやり取りするようなAPIを提供します。

### パラメータイベント
各ノードはパラメータイベントがパブリッシュされるトピックを提供します。このトピックは変更したパラメータを監視することをサポートするためのものです。クライアントライブラリはこのトピックを用いて特定のパラメータ変更のためのコールバックを登録する能力を実装することを期待されます。

### ロギングと再生
全体システムをロギングする際，パラメータの変更はイベントチャンネルの標準的なトピック記録機能を介してロギングできます。再生メカニズムの実装は，パラメータイベントストリームをリッスンし，リモートAPIを介したパラメータ設定コールを呼び出すというものです。

## 現在の実装

上記の仕様はプロトタイプでした。実装は[rclcpp](https://github.com/ros2/rclcpp)で確認できます。遠隔でインターフェイスを利用するサービス定義は[rcl_interfces package](https://github.com/ros2/rcl_interfaces)の中に含まれています。


### 実装されていないもの

現在，いくつかの仕様は実装されていません。
- パラメータ購読の登録はありません。イベントは公開されますが，特定のパラメータに対して変更を行うコールバックを登録する方法はありません。現在，1つのノードの複数パラメータに対してすべての変更を行う1つのコールバックを登録することができます。
- 更新されるよりも前にパラメータの更新を検証するコールバックを登録する機能は利用できません。
- ロギングされたパラメータ変更のロギングや再生をするような操作はありません。
- 期待される検証ポリシーを表示・取得する機能は実装されていません。そのような機能は，パラメータ機能よりも少しだけ高いレベル(階層)で操作することが望まれており，それはライフサイクルのコンポーネントに関係することになりそうです。

## 現在網羅できていない話題

ゆくゆくはここやその他のドキュメントにて議論し，具体化する話題がいまだにあります。いくつか紹介します。

### パラメータの初期化機能

起動時にパラメータを読み込む方法がいくつかあります。これにはコマンドライン引数やroslaunchの引数，そもそものパラメータファイルを含みます。これは新たなlaunchシステムと組み合わせて対処する必要があるものです。

### 静的な確認・検証のための事前宣言用インターフェイス

これは，静的チェックを助け，誤植によって間違ったパラメータを設定してしまうことで発生する論理的なエラーを防ぐことのできるAPIを宣言する機能のことです。ノードは期待されない名前を拒否することでこれを強制できますが，期待されるパラメータ名を知ることが開発者ツールに役立つケースがいくつかあります。